import ROOT

# Open the existing file (vector_sim.root) generated by EventGen.py
input_file = ROOT.TFile.Open("../gen/vector_sim.root")
input_tree = input_file.Get("tree")

# Create a new ROOT file and the NTuple
output_file = ROOT.TFile("ntuple_from_vector.root", "RECREATE")
ntuple = ROOT.TNtuple("ntuple", "NTuple filled from vector_sim", 
                      "run_id:spill_id:event_id:fpga_bits:nim_bits:"
                      "hit_id:detector_id:element_id:tdc_time:drift_distance:"
                      "track_id:charge:x_vtx:y_vtx:z_vtx:px_vtx:py_vtx:pz_vtx")

# Set the branch addresses for the input tree
# Event-level data
run_id = ROOT.std.vector('int')()
spill_id = ROOT.std.vector('int')()
event_id = ROOT.std.vector('int')()
fpga_bits = ROOT.std.vector('int')()
nim_bits = ROOT.std.vector('int')()

# Hit-level data
hit_id = ROOT.std.vector('int')()
detector_id = ROOT.std.vector('int')()
element_id = ROOT.std.vector('int')()
tdc_time = ROOT.std.vector('double')()
drift_distance = ROOT.std.vector('double')()

# Track-level data
track_id = ROOT.std.vector('int')()
charge = ROOT.std.vector('int')()
x_vtx = ROOT.std.vector('double')()
y_vtx = ROOT.std.vector('double')()
z_vtx = ROOT.std.vector('double')()
px_vtx = ROOT.std.vector('double')()
py_vtx = ROOT.std.vector('double')()
pz_vtx = ROOT.std.vector('double')()

# Set the branch addresses
input_tree.SetBranchAddress("run_id", run_id)
input_tree.SetBranchAddress("spill_id", spill_id)
input_tree.SetBranchAddress("event_id", event_id)
input_tree.SetBranchAddress("fpga_bits", fpga_bits)
input_tree.SetBranchAddress("nim_bits", nim_bits)
input_tree.SetBranchAddress("hit_id", hit_id)
input_tree.SetBranchAddress("detector_id", detector_id)
input_tree.SetBranchAddress("element_id", element_id)
input_tree.SetBranchAddress("tdc_time", tdc_time)
input_tree.SetBranchAddress("drift_distance", drift_distance)
input_tree.SetBranchAddress("track_id", track_id)
input_tree.SetBranchAddress("charge", charge)
input_tree.SetBranchAddress("x_vtx", x_vtx)
input_tree.SetBranchAddress("y_vtx", y_vtx)
input_tree.SetBranchAddress("z_vtx", z_vtx)
input_tree.SetBranchAddress("px_vtx", px_vtx)
input_tree.SetBranchAddress("py_vtx", py_vtx)
input_tree.SetBranchAddress("pz_vtx", pz_vtx)

# Create a new ROOT file and the NTuple
output_file = ROOT.TFile("ntuple_from_vector.root", "RECREATE")
ntuple = ROOT.TNtuple("ntuple", "NTuple filled from vector_sim", 
                      "run_id:spill_id:event_id:fpga_bits:nim_bits:"
                      "hit_id:detector_id:element_id:tdc_time:drift_distance:"
                      "track_id:charge:x_vtx:y_vtx:z_vtx:px_vtx:py_vtx:pz_vtx")

# Loop over the events in the input tree and fill the NTuple
n_entries = input_tree.GetEntries()
for i in range(n_entries):
    input_tree.GetEntry(i)
    
    # Ensure hit_id is correctly handled as a vector
    n_hits = hit_id.size()  # Use the .size() method to get the size of ROOT std::vector
    
    # Flatten the vectors and fill the NTuple
    for j in range(n_hits):
        ntuple.Fill(run_id[0], spill_id[0], event_id[0], *fpga_bits, *nim_bits, 
                    hit_id[j], detector_id[j], element_id[j], tdc_time[j], drift_distance[j],
                    track_id[j], charge[j], x_vtx[j], y_vtx[j], z_vtx[j],
                    px_vtx[j], py_vtx[j], pz_vtx[j])


# Write the NTuple to the output file and close
output_file.Write()
output_file.Close()
input_file.Close()

print("NTuple created from vector_sim.root and saved to ntuple_from_vector.root")